{
  "id" : "0e9a87ff-b62e-4661-a0da-8b8a98a5c4b4",
  "name" : "chat_completions",
  "request" : {
    "url" : "/chat/completions",
    "method" : "POST",
    "headers" : {
      "Accept" : {
        "equalTo" : "*/*"
      }
    },
    "bodyPatterns" : [ {
      "equalToJson" : "{\"messages\":[{\"role\":\"system\",\"content\":\"                You are a senior Java developer specializing in converting PL/SQL to maintainable Java code.\\n                \\n                Rules:\\n                • Use only provided context APIs\\n• Maintain exact functional equivalence\\n• Follow Java best practices\\n• Never invent new APIs or field names, all the field names and functions that you need are present in the context that was passed\\n• Include proper error handling\\n• Predicates must only handle a single responsibility, so they can be combined using the predicate api in the top level predicate\\n• Use modern Java features where appropriate\\n                \\n                Available Context APIs:\\n                // Context API:\\nimport com.example.dq.foundation.data.MonetaryValue;\\nimport com.example.dq.foundation.data.OptionalDate;\\nimport lombok.Getter;\\nimport lombok.Setter;\\nimport lombok.ToString;\\n\\nimport java.math.BigDecimal;\\nimport java.time.Duration;\\n\\n@Getter\\n@Setter\\n@ToString\\npublic final class Cover implements Sp4ConsumerEntity {\\n    private Long pk;\\n    private String coverId;\\n    private String localCustId;\\n    private Customer cust;\\n    private String higherLimitId;\\n    private String limitId;\\n    private Limit limit;\\n    private String coverType;\\n    private MonetaryValue lastKnownCoverVal;\\n    private BigDecimal lastKnownCoverPct;\\n    private String coverClassType;\\n    private String assetMfr;\\n    private String assetModel;\\n    private Integer assetBuildYear;\\n    private OptionalDate coverValDate = OptionalDate.empty();\\n    private String coverRank;\\n    private String coverClassQual;\\n    private String coverObjUse;\\n    private String coverPostalCode;\\n    private String coverCountry;\\n    private String coverProvider;\\n    private OptionalDate coverStartDt = OptionalDate.empty();\\n    private OptionalDate coverEndDt = OptionalDate.empty();\\n    private Duration coverExecDurPeriod;\\n    private String contractualMat;\\n    private String objId;\\n    private String energyEffRating;\\n    private OptionalDate energyLabelDt = OptionalDate.empty();\\n    private String coverStatus;\\n    private String crrEligible;\\n    private String crnValRacp;\\n    private boolean generated = false;\\n}\\n\\n// Context API:\\nimport com.example.dq.foundation.data.MonetaryValue;\\nimport com.example.dq.foundation.data.OptionalDate;\\nimport lombok.Getter;\\nimport lombok.Setter;\\nimport lombok.ToString;\\n\\n@Getter\\n@Setter\\n@ToString\\npublic final class CoverValue implements Sp4ConsumerEntity {\\n    private String localCustId;\\n    private String coverId;\\n    private Cover cover;\\n    private String higherLimitId;\\n    private String limitId;\\n    private String coverValType;\\n    private MonetaryValue coverAmt;\\n    private OptionalDate coverValDate = OptionalDate.empty();\\n    private boolean generated = false;\\n}\\n\\n// Context API:\\nimport com.example.dq.foundation.data.MonetaryValue;\\nimport com.example.dq.foundation.data.OptionalDate;\\nimport lombok.Getter;\\nimport lombok.Setter;\\nimport lombok.ToString;\\n\\n@Getter\\n@Setter\\n@ToString\\npublic final class Customer implements Sp4ConsumerEntity {\\n    private Long pk;\\n    private String localCustId;\\n    private OptionalDate dob = OptionalDate.empty();\\n    private String custType;\\n    private String custNationality;\\n    private String countryOfResidence;\\n    private MonetaryValue income;\\n    private String incomeBase;\\n    private String maritalStatus;\\n    private String industry;\\n    private String workAgreement;\\n    private String educationLevel;\\n    private String custSegment;\\n    private String custPostalCode;\\n    private boolean generated = false;\\n}\\n\\n// Context API:\\nimport com.example.dq.foundation.DqContext;\\nimport com.example.dq.foundation.EventService;\\nimport lombok.Getter;\\nimport lombok.RequiredArgsConstructor;\\n\\nimport java.time.LocalDate;\\n\\n@Getter\\n@RequiredArgsConstructor\\npublic class ConsumerDqContext implements DqContext {\\n    private final EventService eventService;\\n    private final ReferenceDataCache cache;\\n    private final ConsumerEnrichmentService enrichmentService;\\n    private final String sourceSystemId;\\n    private final LocalDate reportingDate;\\n\\n    @Override\\n    public EventService getEventService() {\\n        return eventService;\\n    }\\n}\\n\\n// Context API:\\npublic interface ConsumerEnrichmentService {\\n    BinaryIndicator getBinaryIndicator(String code);\\n\\n    Country getCountry(String countryCode);\\n\\n    CreditCommitmentIndicator getCreditCommitmentIndicator(String code);\\n\\n    Currency getCurrency(String code);\\n\\n    Default getDefault(String code);\\n\\n    DependentDefault getDependentDefault(String fieldName, String value);\\n\\n    DerecognitionReason getDerecognitionReason(String code);\\n\\n    EadModel getEadModel(String code);\\n\\n    Set<ExpectedFiles> getExpectedFiles(String sourceSystemId);\\n\\n    FacilityPurpose getFacilityPurpose(String code);\\n\\n    GeneralIndicator getGeneralIndicator(String code);\\n\\n    LoanStatus getLoanStatus(String code);\\n\\n    Mapping getMapping(String fieldName, String systemValue);\\n\\n    PociTp getPociTp(String code);\\n\\n    RepaymentScheduleType getRepaymentScheduleType(String code);\\n\\n    RiskRatingType getRiskRatingType(String code);\\n\\n    SourceSystem getSourceSystem(String sourceSystemId);\\n\\n    MonetaryValue convertToEuro(MonetaryValue monetaryValue);\\n\\n    List<RuleAssignment> getRuleAssignments(String processCode, String ruleCode);\\n\\n    List<FunctionalParameter> getFunctionalParameters(String code);\\n\\n    FlattenedTreeElement getLimitTypeTreeElement(String childCode, int levelParent);\\n\\n    FlattenedTreeElement getLimitTypeTreeElementLowestLevel(String childCode);\\n\\n    List<FlattenedTreeElement> getRiskRatingTreeElements(String childCode);\\n\\n    LimitType getLimitType(String code);\\n\\n    boolean isSecuritisationCodePresent(String securitisationCode);\\n\\n    boolean outstandingAmountTypePresent(String outstandingAmountType);\\n\\n    boolean outstandingAmountTypeSupported(String code);\\n}\\n\\n// Context API:\\npublic interface ExecutionBlock<T, U extends DqContext> {\\n    void execute(T item, U context);\\n}\\n\\n// Context API:\\nimport com.example.dq.foundation.data.MonetaryValue;\\nimport com.example.dq.foundation.data.OptionalDate;\\nimport lombok.Getter;\\nimport lombok.Setter;\\nimport lombok.ToString;\\n\\nimport java.math.BigDecimal;\\nimport java.time.Duration;\\nimport java.util.ArrayList;\\nimport java.util.Comparator;\\nimport java.util.HashSet;\\nimport java.util.List;\\nimport java.util.Optional;\\nimport java.util.Set;\\n\\nimport static itrf.vortex.spdi.util.OptionalDateUtil.getMaxDate;\\n\\n@Getter\\n@Setter\\n@ToString\\npublic final class Limit implements Sp4ConsumerEntity {\\n    @ToString.Exclude\\n    private final List<Outstanding> outstdngs = new ArrayList<>();\\n    @ToString.Exclude\\n    private final List<Limit> subLimits = new ArrayList<>();\\n    private Long pk;\\n    private String limitId;\\n    private LimitTypeIndicator limitTypeInd;\\n    private String localCustId;\\n    @ToString.Exclude\\n    private Customer cust;\\n    private String higherLimitId;\\n    @ToString.Exclude\\n    private Limit higherLimit;\\n    private String prodType; // This is referred to as LimitType or FacilityType in the FD\\n    private MonetaryValue origLimitAmt;\\n    private MonetaryValue limitAmt;\\n    private OptionalDate limitStartDt = OptionalDate.empty();\\n    private OptionalDate limitEndDt = OptionalDate.empty();\\n    private String purpose;\\n    private String bookOffice;\\n    private String salesChnl;\\n    private String exampleLegalEntity;\\n    private String baseEntity;\\n    private String creditRatingScoreAtApp;\\n    private String creditRiskRating;\\n    @ToString.Exclude\\n    private List<RiskRating> riskRatingsLvl1 = new ArrayList<>();\\n    @ToString.Exclude\\n    private List<RiskRating> riskRatingsLvl2 = new ArrayList<>();\\n    @ToString.Exclude\\n    private List<RiskRating> riskRatingsLvl3 = new ArrayList<>();\\n    private BigDecimal probOfDefaultAtOrig;\\n    private OptionalDate probOfDefaultOrigDt = OptionalDate.empty();\\n    private String bankCreditRiskRatingAtOrig;\\n    private BigDecimal probOfDefault;\\n    private BigDecimal lossGivenDefault;\\n    private MonetaryValue expAtDefault;\\n    private String contractualMat;\\n    private String revolving;\\n    private String advised;\\n    private String committed;\\n    private String forbearanceMeas;\\n    private String forbearanceStatus;\\n    private OptionalDate forbearanceStartDt = OptionalDate.empty();\\n    private OptionalDate forbearanceProbStartDt = OptionalDate.empty();\\n    private OptionalDate offerIssueDt = OptionalDate.empty();\\n    private OptionalDate docCompletionDt = OptionalDate.empty();\\n    private String limitLifecycleStatus;\\n    private OptionalDate limitLifecycleStatusDt = OptionalDate.empty();\\n    private OptionalDate offerAcceptDt = OptionalDate.empty();\\n    private String bridgeLoan;\\n    private String creditFraud;\\n    private Duration noticePeriod;\\n    private String defaultReason;\\n    private OptionalDate derecognitionDt = OptionalDate.empty();\\n    private String derecognitionReason;\\n    private String purchasedOrOrigCreditImpaired;\\n    private String problemLoanDept;\\n    private String pdArrearsSubmodelUsed;\\n    private String forbearanceMeas2;\\n    private String forbearanceMeas3;\\n    private String forbearanceMeas4;\\n    private String forbearanceMeas5;\\n    private String recourse;\\n    private String financingType;\\n    private Duration defaultDaysPastDue;\\n    private OptionalDate absBreachStartDt = OptionalDate.empty();\\n    private MonetaryValue absBreachPastDueAmt;\\n    private OptionalDate absBreachEndDt = OptionalDate.empty();\\n    private OptionalDate relBreachStartDt = OptionalDate.empty();\\n    private MonetaryValue relBreachPastDueAmt;\\n    private MonetaryValue relBreachOutstdngAmt;\\n    private OptionalDate relBreachEndDt = OptionalDate.empty();\\n    private String debtCollection;\\n    private MonetaryValue npvOld;\\n    private MonetaryValue npvNew;\\n    private BigDecimal npvLoss;\\n    private OptionalDate npvImpactCalcDt = OptionalDate.empty();\\n    private String origLimitId;\\n    private String origHigherLimitId;\\n    private String origSystemId;\\n    private String newLimitId;\\n    private String newHigherLimitId;\\n    private String newSystemId;\\n    private OptionalDate forbearanceMeasStartDt = OptionalDate.empty();\\n    private OptionalDate forbearanceMeasEndDt = OptionalDate.empty();\\n    private OptionalDate forbearanceMeasStartDt2 = OptionalDate.empty();\\n    private OptionalDate forbearanceMeasEndDt2 = OptionalDate.empty();\\n    private OptionalDate forbearanceMeasStartDt3 = OptionalDate.empty();\\n    private OptionalDate forbearanceMeasEndDt3 = OptionalDate.empty();\\n    private OptionalDate forbearanceMeasStartDt4 = OptionalDate.empty();\\n    private OptionalDate forbearanceMeasEndDt4 = OptionalDate.empty();\\n    private OptionalDate forbearanceMeasStartDt5 = OptionalDate.empty();\\n    private OptionalDate forbearanceMeasEndDt5 = OptionalDate.empty();\\n    private String inForbearance;\\n    private OptionalDate transactorOverdraftLastDrawDt = OptionalDate.empty();\\n    private OptionalDate transactorCardLastDtNotRepaidInFull = OptionalDate.empty();\\n    private String eadModel;\\n    private MonetaryValue eadIfrs9;\\n    private MonetaryValue eadIncap;\\n    private MonetaryValue eadRegcap;\\n    private String lgdModel;\\n    private String lgdSegment;\\n    private String lgdPool;\\n    private BigDecimal facilityLoanToValueNorm;\\n    private String facilityLoanToIncomeNorm;\\n    private String eadCalcId;\\n    private String lgdCalcId;\\n    private OptionalDate creditCommitmentStartDt = OptionalDate.empty();\\n    private String creditCommitment;\\n    private OptionalDate firstDrawDt = OptionalDate.empty();\\n    private String pdCalcId;\\n    private String collectiveSicrInd;\\n    private OptionalDate collectiveSicrStartDt = OptionalDate.empty();\\n    private OptionalDate collectiveSicrEndDt = OptionalDate.empty();\\n    private boolean generated = false;\\n\\n    public OptionalDate getLatestForbearanceMeasStartDt() {\\n        return getMaxDate(\\n                forbearanceMeasStartDt,\\n                forbearanceMeasStartDt2,\\n                forbearanceMeasStartDt3,\\n                forbearanceMeasStartDt4,\\n                forbearanceMeasStartDt5\\n        );\\n    }\\n\\n    /**\\n     * Returns the latest risk rating for the given rating level.\\n     *\\n     * @param ratingLevel The rating level to search for\\n     * @return The latest risk rating for the given rating level, or {@code null} if no risk rating was found\\n     */\\n    public RiskRating getLatestRiskRating(String ratingLevel) {\\n        return switch (ratingLevel) {\\n            case \\\"1\\\" -> findLatestRiskRating(riskRatingsLvl1);\\n            case \\\"2\\\" -> findLatestRiskRating(riskRatingsLvl2);\\n            case \\\"3\\\" -> findLatestRiskRating(riskRatingsLvl3);\\n            default -> null;\\n        };\\n    }\\n\\n    private RiskRating findLatestRiskRating(List<RiskRating> riskRatings) {\\n        return riskRatings.stream()\\n                .max(Comparator.comparing(riskRating ->\\n                        riskRating.getCreditRiskRatingDate().localDate()))\\n                .orElse(null);\\n    }\\n\\n    /**\\n     * Searches for a circular reference where this limit appears in its own parent hierarchy.\\n     *\\n     * @return An {@code Optional} set of limits making up the circular reference, or an empty {@code Optional} if no\\n     * circular reference was found\\n     */\\n    public Optional<Set<Limit>> findCircularReference() {\\n        Set<Limit> seen = new HashSet<>();\\n        Limit current = this.getHigherLimit();\\n        while (current != this && current != current.getHigherLimit() && !seen.contains(current)) {\\n            seen.add(current);\\n            current = current.getHigherLimit();\\n        }\\n        if (current == current.getHigherLimit() || seen.contains(current)) {\\n            return Optional.empty();\\n        }\\n        seen.add(this);\\n        return Optional.of(seen);\\n    }\\n\\n    public enum LimitTypeIndicator {\\n        /**\\n         * An independent limit is a limit which has no higher or lower level limits associated with it. An independent\\n         * limit should have itself as its higher level limit.\\n         */\\n        INDEPENDENT,\\n\\n        /**\\n         * A cross limit is a limit which has lower level limits associated with it. Within a limit tree, a cross limit\\n         * represents any node which is not a leaf.\\n         */\\n        CROSS,\\n\\n        /**\\n         * A sub limit is a limit which does not have any lower level limits associated with it, but does have a higher\\n         * level limit. Within a limit tree, a sub limit represents any leaf node.\\n         */\\n        SUB\\n    }\\n}\\n\\n// Context API:\\nimport java.math.BigDecimal;\\n\\npublic record MonetaryValue(String currency, BigDecimal value) {\\n\\n    /**\\n     * The expected number of characters in a currency string.\\n     */\\n    private static final int CURRENCY_SIZE = 3;\\n\\n    /**\\n     * A {@code MonetaryValue} of zero euros.\\n     */\\n    public static final MonetaryValue EUR_ZERO = new MonetaryValue(\\\"EUR\\\", BigDecimal.ZERO);\\n\\n    /**\\n     * Returns the zero value for the given currency.\\n     *\\n     * @param currency The currency for which the zero value is requested\\n     * @return A {@code MonetaryValue} which represents a value of zero in the given currency\\n     */\\n    public static MonetaryValue zero(String currency) {\\n        return new MonetaryValue(currency, BigDecimal.ZERO);\\n    }\\n\\n    /**\\n     * Parse a string in the format {@code EUR-100.00} as a {@code MonetaryValue}.\\n     *\\n     * @param ccyAmountType The string representation to parse\\n     * @return A monetary value\\n     * @throws NumberFormatException if the numeric part of {@code ccyAmountType} cannot be parsed as a\\n     *                               {@link BigDecimal}\\n     */\\n    public static MonetaryValue parse(String ccyAmountType) {\\n        return new MonetaryValue(\\n                ccyAmountType.substring(0, CURRENCY_SIZE),\\n                new BigDecimal(ccyAmountType.substring(CURRENCY_SIZE))\\n        );\\n    }\\n\\n    /**\\n     * Serialize a {@code MonetaryValue} in the format {@code EUR-100.00}.\\n     *\\n     * @return A string representation of this {@code MonetaryValue}\\n     */\\n    public String serialize() {\\n        return currency() + value();\\n    }\\n\\n    /**\\n     * Returns the signum function of this {@code MonetaryValue}.\\n     *\\n     * @return -1, 0, or 1 as the value of this {@code MonetaryValue} is negative, zero, or positive.\\n     */\\n    public int signum() {\\n        return value.signum();\\n    }\\n\\n    /**\\n     * Checks if two instances of {@code MonetaryValue} represent the same value.\\n     *\\n     * @param other The {@code MonetaryValue} to compare with\\n     * @return {@code true} if two instances of {@code MonetaryValue} represent the same value, {@code false} otherwise.\\n     */\\n    public boolean equals(MonetaryValue other) {\\n        return currency.equals(other.currency) && value.compareTo(other.value) == 0;\\n    }\\n}\\n\\n// Context API:\\nimport java.sql.Date;\\nimport java.time.LocalDate;\\nimport java.time.chrono.ChronoLocalDate;\\nimport java.time.temporal.TemporalUnit;\\n\\npublic record OptionalDate(LocalDate localDate) implements Comparable<OptionalDate> {\\n\\n    /**\\n     * Common instance for {@code maximum()}.\\n     */\\n    public static final OptionalDate MAX = new OptionalDate(LocalDate.MAX);\\n    /**\\n     * Common instance for {@code empty()}.\\n     */\\n    private static final OptionalDate EMPTY_OPTIONAL_DATE = new OptionalDate(null);\\n\\n    /**\\n     * Returns an empty {@code OptionalDate} instance. No value is present for this {@code OptionalDate}.\\n     *\\n     * @return an empty {@code OptionalDate}\\n     * @apiNote Though it may be tempting to do so, avoid testing if an object is empty by comparing with {@code ==} or\\n     * {@code !=} against instances returned by {@code OptionalDate.empty()}. There is no guarantee that it is a\\n     * singleton. Instead, use {@link #isEmpty()} or {@link #isPresent()}.\\n     */\\n    public static OptionalDate empty() {\\n        return EMPTY_OPTIONAL_DATE;\\n    }\\n\\n    /**\\n     * Obtains an instance of {@code OptionalDate} from a text string such as {@code 2007-12-03}. Defers parsing to\\n     * {@link LocalDate#parse(CharSequence)}. If the input is {@code null} or an empty string, an empty\\n     * {@code OptionalDate} is returned.\\n     *\\n     * @param text the text to parse such as \\\"2007-12-03\\\", a null value or an empty string\\n     * @return the parsed local date, not null\\n     * @throws java.time.format.DateTimeParseException if the text cannot be parsed\\n     */\\n    public static OptionalDate parse(String text) {\\n        return text == null || text.isEmpty() ? OptionalDate.empty() : new OptionalDate(LocalDate.parse(text));\\n    }\\n\\n    /**\\n     * Obtains an instance of {@code OptionalDate} from a year, month and day.\\n     * <p>\\n     * This returns a {@code OptionalDate} with the specified year, month and day-of-month.\\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\\n     *\\n     * @param year       the year to represent, from MIN_YEAR to MAX_YEAR\\n     * @param month      the month-of-year to represent, from 1 (January) to 12 (December)\\n     * @param dayOfMonth the day-of-month to represent, from 1 to 31\\n     * @return the local date, not null\\n     * @throws java.time.DateTimeException if the value of any field is out of range, or if the day-of-month is invalid\\n     *                                     for the month-year\\n     */\\n    public static OptionalDate of(int year, int month, int dayOfMonth) {\\n        return new OptionalDate(LocalDate.of(year, month, dayOfMonth));\\n    }\\n\\n    /**\\n     * If a value is  not present, returns {@code true}, otherwise {@code false}.\\n     *\\n     * @return {@code true} if a value is not present, otherwise {@code false}\\n     */\\n    public boolean isEmpty() {\\n        return localDate == null;\\n    }\\n\\n    /**\\n     * If a value is present, returns {@code true}, otherwise {@code false}.\\n     *\\n     * @return {@code true} if a value is present, otherwise {@code false}\\n     */\\n    public boolean isPresent() {\\n        return localDate != null;\\n    }\\n\\n    /**\\n     * Checks if this {@code OptionalDate} is before the specified date.\\n     * <p>\\n     * This checks to see if this date represents a point on the local time-line before the other date.\\n     * <p>\\n     * If this {@code OptionalDate} is empty, or if the specified date is null, this method will always return\\n     * {@code false}.\\n     *\\n     * @param other the other date to compare to\\n     * @return true if this date is before the specified date\\n     */\\n    public boolean isBefore(ChronoLocalDate other) {\\n        return localDate != null && other != null && localDate.isBefore(other);\\n    }\\n\\n    /**\\n     * Checks if this {@code OptionalDate} is before the specified date.\\n     * <p>\\n     * This checks to see if this date represents a point on the local time-line before the other date.\\n     * <p>\\n     * If this {@code OptionalDate} is empty, or if the specified date is null or empty, this method will always return\\n     * {@code false}.\\n     *\\n     * @param other the other date to compare to\\n     * @return true if this date is before the specified date\\n     */\\n    public boolean isBefore(OptionalDate other) {\\n        return other != null && isBefore(other.localDate);\\n    }\\n\\n    /**\\n     * Checks if this {@code OptionalDate} is before or on the specified date.\\n     * <p>\\n     * This checks to see if this date represents a point on the local time-line before or on the other date.\\n     * <p>\\n     * If this {@code OptionalDate} is empty, or if the specified date is null, this method will always return\\n     * {@code false}.\\n     *\\n     * @param other the other date to compare to\\n     * @return true if this date is before or on the specified date\\n     */\\n    public boolean isBeforeOrEquals(ChronoLocalDate other) {\\n        return localDate != null && other != null && (localDate.equals(other) || localDate.isBefore(other));\\n    }\\n\\n    /**\\n     * Checks if this {@code OptionalDate} is before or on the specified date.\\n     * <p>\\n     * This checks to see if this date represents a point on the local time-line before or on the other date.\\n     * <p>\\n     * If this {@code OptionalDate} is empty, or if the specified date is null or empty, this method will always return\\n     * {@code false}.\\n     *\\n     * @param other the other date to compare to\\n     * @return true if this date is before or on the specified date\\n     */\\n    public boolean isBeforeOrEquals(OptionalDate other) {\\n        return other != null && isBeforeOrEquals(other.localDate);\\n    }\\n\\n    /**\\n     * Checks if this {@code OptionalDate} is after the specified date.\\n     * <p>\\n     * This checks to see if this date represents a point on the local time-line after the other date.\\n     * <p>\\n     * If this {@code OptionalDate} is empty, or if the specified date is null, this method will always return\\n     * {@code false}.\\n     *\\n     * @param other the other date to compare to\\n     * @return true if this date is after the specified date\\n     */\\n    public boolean isAfter(ChronoLocalDate other) {\\n        return localDate != null && other != null && localDate.isAfter(other);\\n    }\\n\\n    /**\\n     * Checks if this {@code OptionalDate} is after the specified date.\\n     * <p>\\n     * This checks to see if this date represents a point on the local time-line after the other date.\\n     * <p>\\n     * If this {@code OptionalDate} is empty, or if the specified date is null or empty, this method will always return\\n     * {@code false}.\\n     *\\n     * @param other the other date to compare to\\n     * @return true if this date is after the specified date\\n     */\\n    public boolean isAfter(OptionalDate other) {\\n        return other != null && isAfter(other.localDate);\\n    }\\n\\n    /**\\n     * Checks if this {@code OptionalDate} is after or on the specified date.\\n     * <p>\\n     * This checks to see if this date represents a point on the local time-line after or on the other date.\\n     * <p>\\n     * If this {@code OptionalDate} is empty, or if the specified date is null, this method will always return\\n     * {@code false}.\\n     *\\n     * @param other the other date to compare to\\n     * @return true if this date is after or on the specified date\\n     */\\n    public boolean isAfterOrEquals(ChronoLocalDate other) {\\n        return localDate != null && other != null && (localDate.equals(other) || localDate.isAfter(other));\\n    }\\n\\n    /**\\n     * Checks if this {@code OptionalDate} is after or on the specified date.\\n     * <p>\\n     * This checks to see if this date represents a point on the local time-line after or on the other date.\\n     * <p>\\n     * If this {@code OptionalDate} is empty, or if the specified date is null or empty, this method will always return\\n     * {@code false}.\\n     *\\n     * @param other the other date to compare to\\n     * @return true if this date is after or on the specified date\\n     */\\n    public boolean isAfterOrEquals(OptionalDate other) {\\n        return other != null && isAfterOrEquals(other.localDate);\\n    }\\n\\n    /**\\n     * Checks if this date is equal to the specified date.\\n     * <p>\\n     * This checks to see if this date represents the same point on the local time-line as the other date.\\n     *\\n     * @param other the other date to compare to, not null\\n     * @return true if this date is equal to the specified date\\n     */\\n    public boolean isEqual(OptionalDate other) {\\n        if (localDate == null) {\\n            return other == null || other.localDate == null;\\n        } else if (other == null || other.localDate == null) {\\n            return false;\\n        }\\n        return localDate.isEqual(other.localDate);\\n    }\\n\\n    /**\\n     * Create a new optional date that is {@code amountToAdd} {@code unit} later. If this optional date is empty,\\n     * nothing happens.\\n     *\\n     * @param amountToAdd the amount of the unit to add to the result, may be negative\\n     * @param unit        the unit of the amount to add, not null\\n     * @return a {@code OptionalDate} based on this date with the specified amount added, not null, but may be empty\\n     */\\n    public OptionalDate plus(long amountToAdd, TemporalUnit unit) {\\n        if (localDate == null) {\\n            return this;\\n        }\\n        return new OptionalDate(localDate.plus(amountToAdd, unit));\\n    }\\n\\n    /**\\n     * Create a new optional date that is {@code amountToAdd} {@code unit} earlier. If this optional date is empty,\\n     * nothing happens.\\n     *\\n     * @param amountToAdd the amount of the unit to subtract from the result, may be negative\\n     * @param unit        the unit of the amount to subtract, not null\\n     * @return a {@code OptionalDate} based on this date with the specified amount subtracted, not null, but may be\\n     * empty\\n     */\\n    public OptionalDate minus(long amountToAdd, TemporalUnit unit) {\\n        if (localDate == null) {\\n            return this;\\n        }\\n        return new OptionalDate(localDate.minus(amountToAdd, unit));\\n    }\\n\\n    /**\\n     * Create a new optional date that is {@code daysToAdd} later. If this optional date is empty, nothing happens.\\n     *\\n     * @param daysToAdd the days to add, may be negative\\n     * @return an {@code OptionalDate} based on this date with the days added, not null, but may be empty\\n     */\\n    public OptionalDate plusDays(long daysToAdd) {\\n        if (localDate == null) {\\n            return this;\\n        }\\n        return new OptionalDate(localDate.plusDays(daysToAdd));\\n    }\\n\\n    /**\\n     * Returns the latest of this optional date and another optional date. If both optional dates are empty, an empty\\n     * optional date is returned. If one optional date is empty, the non-empty optional date is returned.\\n     *\\n     * @param other the optional date to compare this optional date with\\n     * @return an {@code OptionalDate} which is the max of this and {@code other}, not null, but may be empty\\n     */\\n    public OptionalDate max(OptionalDate other) {\\n        if (localDate == null) {\\n            return other == null ? OptionalDate.empty() : other;\\n        }\\n        if (other == null || other.localDate == null || localDate.isAfter(other.localDate)) {\\n            return this;\\n        }\\n        return other;\\n    }\\n\\n    /**\\n     * Returns the earliest of this optional date and another optional date. If both optional dates are empty, an empty\\n     * optional date is returned. If one optional date is empty, the non-empty optional date is returned.\\n     *\\n     * @param other the optional date to compare this optional date with\\n     * @return an {@code OptionalDate} which is the min of this and {@code other}, not null, but may be empty\\n     */\\n    public OptionalDate min(OptionalDate other) {\\n        if (localDate == null) {\\n            return other == null ? OptionalDate.empty() : other;\\n        }\\n        if (other == null || other.localDate == null || localDate.isBefore(other.localDate)) {\\n            return this;\\n        }\\n        return other;\\n    }\\n\\n    /**\\n     * Checks if this {@code OptionalDate} is in between the specified fromDate and untilDate.\\n     * <p>\\n     * This checks to see if this date represents a point on the local time-line after or on the fromDate\\n     * and before or on the untilDate. If the untilDate is null, it will only check if it is after or on the fromDate.\\n     * <p>\\n     * If this {@code OptionalDate} is empty, or if the fromDate is null, this method will always return {@code false}.\\n     *\\n     * @param fromDate  the start date to compare to, not null\\n     * @param untilDate the end date to compare to, may be null\\n     * @return true if this date is in between the specified dates\\n     */\\n    public boolean isBetween(OptionalDate fromDate, OptionalDate untilDate) {\\n        if (fromDate == null || !isPresent()) {\\n            return false;\\n        }\\n        boolean afterOrEqualsFromDate = isAfterOrEquals(fromDate);\\n        boolean beforeOrEqualsUntilDate = untilDate == null || untilDate.isEmpty() || isBeforeOrEquals(untilDate);\\n        return afterOrEqualsFromDate && beforeOrEqualsUntilDate;\\n    }\\n\\n    /**\\n     * Converts an {@code OptionalDate} into an SQL {@code Date}.\\n     *\\n     * @return {@code null} if the {@code OptionalDate} if empty, an SQL {@code Date} otherwise\\n     */\\n    public Date toSqlDate() {\\n        if (isEmpty()) {\\n            return null;\\n        }\\n        return Date.valueOf(localDate());\\n    }\\n\\n    @Override\\n    public int compareTo(OptionalDate other) {\\n        if (this.isEmpty() && other.isEmpty()) {\\n            return 0;\\n        }\\n        if (other.isEmpty()) {\\n            return 1;\\n        }\\n        if (this.isEmpty()) {\\n            return -1;\\n        }\\n        return this.localDate.compareTo(other.localDate);\\n    }\\n}\\n\\n// Context API:\\nimport com.example.dq.foundation.data.MonetaryValue;\\nimport com.example.dq.foundation.data.OptionalDate;\\nimport lombok.Getter;\\nimport lombok.Setter;\\nimport lombok.ToString;\\n\\nimport java.math.BigDecimal;\\nimport java.math.BigInteger;\\nimport java.math.RoundingMode;\\nimport java.time.Duration;\\n\\n@Getter\\n@Setter\\n@ToString\\npublic final class Outstanding implements Sp4ConsumerEntity {\\n\\n    private static final BigDecimal MAX_PAST_DUE_AMT = BigDecimal.valueOf(999);\\n\\n    private Long pk;\\n    private String localCustId;\\n    private Customer cust;\\n    private String higherLimitId;\\n    private String limitId;\\n    private Limit limit;\\n    private MonetaryValue outstdngAmt;\\n    private OptionalDate nextPayDt = OptionalDate.empty();\\n    private Duration fixedIntPeriod;\\n    private BigDecimal contractIntRate;\\n    private OptionalDate nextIntResetDt = OptionalDate.empty();\\n    private Duration repayFreq;\\n    private Duration intPayFreq;\\n    private MonetaryValue nextInstalAmt;\\n    private Duration daysPastDue;\\n    private MonetaryValue pastDueAmt;\\n    private MonetaryValue principalPastDueAmt;\\n    private MonetaryValue intPastDueAmt;\\n    private MonetaryValue feesPastDueAmt;\\n    private BigInteger paymentsOverdue;\\n    private OptionalDate oldestArrearDt = OptionalDate.empty();\\n    private MonetaryValue writeOffAmt;\\n    private OptionalDate latestWriteOffDt = OptionalDate.empty();\\n    private OptionalDate reportedInfectedDt = OptionalDate.empty();\\n    private OptionalDate outstdngStartDt = OptionalDate.empty();\\n    private OptionalDate outstdngEndDt = OptionalDate.empty();\\n    private String baseEntity;\\n    private String outstdngId;\\n    private String dept;\\n    private BigDecimal intCapRate;\\n    private BigDecimal intFloorRate;\\n    private String intRefRate;\\n    private BigDecimal intMargin;\\n    private OptionalDate firstRepayDt = OptionalDate.empty();\\n    private MonetaryValue balloonRepayAmt;\\n    private String repaySchedType;\\n    private String ifrs9MeasCat;\\n    private String ifrs9AcctClass;\\n    private MonetaryValue cumWriteOffAmt;\\n    private MonetaryValue addWriteOffAmt;\\n    private BigInteger payReminders;\\n    private String eadCalcId;\\n    private String lgdCalcId;\\n    private boolean generated = false;\\n\\n    public BigInteger getDefaultPaymentsOverdue() {\\n        BigDecimal pda = pastDueAmt.value();\\n        BigDecimal nia = nextInstalAmt.value();\\n        BigDecimal result = pda.divide(nia, RoundingMode.CEILING);\\n        if (result.compareTo(MAX_PAST_DUE_AMT) > 0) {\\n            result = MAX_PAST_DUE_AMT;\\n        }\\n\\n        return result.toBigInteger();\\n    }\\n\\n    /**\\n     * Return the number of days until the next interest payment or repayment.\\n     * <p>\\n     * If both the interest payment frequency and repayment frequency are missing, this method will return {@code null}.\\n     * If only one of the fields is missing, the value of the other field is returned. If both fields are present, the\\n     * smallest number of days until either of these is returned.\\n     *\\n     * @return The number of days until the next payment.\\n     */\\n    public Long getNumberOfDaysUntilNextPayment() {\\n        if (intPayFreq == null) {\\n            if (repayFreq == null) {\\n                return 0L;\\n            }\\n\\n            return repayFreq.toDays();\\n        }\\n\\n        if (repayFreq == null) {\\n            return intPayFreq.toDays();\\n        }\\n\\n        return Long.min(intPayFreq.toDays(), repayFreq.toDays());\\n    }\\n}\\n\\n// Context API:\\nimport com.example.dq.foundation.data.MonetaryValue;\\nimport lombok.Getter;\\nimport lombok.Setter;\\nimport lombok.ToString;\\n\\n@Getter\\n@Setter\\n@ToString\\npublic final class OutstandingAmount implements Sp4ConsumerEntity {\\n    private String outstdngId;\\n    private Outstanding outstdng;\\n    private String localCustId;\\n    private String higherLimitId;\\n    private String limitId;\\n    private String outstdngAmtType;\\n    private MonetaryValue outstdngAmt;\\n    private boolean generated = false;\\n}\\n\\n// Context API:\\nimport com.example.dq.foundation.data.MonetaryValue;\\nimport com.example.dq.foundation.data.OptionalDate;\\nimport lombok.Getter;\\nimport lombok.Setter;\\nimport lombok.ToString;\\n\\n@Getter\\n@Setter\\n@ToString\\npublic final class RepaymentSchedule implements Sp4ConsumerEntity {\\n    private Long pk;\\n    private String localCustId;\\n    private String higherLimitId;\\n    private String limitId;\\n    private Limit limit;\\n    private String outstdngId;\\n    private Outstanding outstdng;\\n    private OptionalDate repayDt = OptionalDate.empty();\\n    private MonetaryValue repayAmt;\\n    private boolean generated = false;\\n}\\n\\n// Context API:\\nimport com.example.dq.foundation.data.MonetaryValue;\\nimport com.example.dq.foundation.data.OptionalDate;\\nimport lombok.Getter;\\nimport lombok.Setter;\\nimport lombok.ToString;\\n\\nimport java.time.Duration;\\n\\n@Getter\\n@Setter\\n@ToString\\npublic final class RiskRating implements Sp4ConsumerEntity {\\n    private Long pk;\\n    private String rtngLvl;\\n    private String locCustId;\\n    private Customer cust;\\n    private String highLvlLmtId;\\n    private String lmtId;\\n    private Limit lmt;\\n    private LimitStore relLmts = new LimitStore();\\n    private String crdtRiskRtng;\\n    private OptionalDate crdtRiskRtngDt = OptionalDate.empty();\\n    private Duration dfltDaysPastDue;\\n    private OptionalDate absBreachStartDt = OptionalDate.empty();\\n    private MonetaryValue absBreachPastDueAmt;\\n    private OptionalDate absBreachEndDt = OptionalDate.empty();\\n    private OptionalDate relBreachStartDt = OptionalDate.empty();\\n    private MonetaryValue relBreachPastDueAmt;\\n    private MonetaryValue relBreachOutstdngAmt;\\n    private OptionalDate relBreachEndDt = OptionalDate.empty();\\n    private OptionalDate dfltStartDt = OptionalDate.empty();\\n    private OptionalDate dfltProbPeriodStartDt = OptionalDate.empty();\\n    private OptionalDate dfltEndDt = OptionalDate.empty();\\n    private String over90DaysDfltPastDue;\\n    private OptionalDate over90DaysDfltPastDueStartDt = OptionalDate.empty();\\n    private OptionalDate over90DaysDfltPastDueEndDt = OptionalDate.empty();\\n    private String utpDistressedRestructurExample;\\n    private OptionalDate utpDistressedRestructurExampleDt = OptionalDate.empty();\\n    private String utpBankruptcy;\\n    private OptionalDate utpBankruptcyStartDt = OptionalDate.empty();\\n    private OptionalDate utpBankruptcyEndDt = OptionalDate.empty();\\n    private String utpEarlyTermExample;\\n    private OptionalDate utpEarlyTermExampleDt = OptionalDate.empty();\\n    private String utpSaleAtALoss;\\n    private OptionalDate utpSaleAtALossDt = OptionalDate.empty();\\n    private String utpForbearanceProbViolation;\\n    private OptionalDate utpForbearanceProbViolationDt = OptionalDate.empty();\\n    private String utpNonAccrued;\\n    private OptionalDate utpNonAccruedStartDt = OptionalDate.empty();\\n    private OptionalDate utpNonAccruedEndDt = OptionalDate.empty();\\n    private String utp3MonthsArrears;\\n    private OptionalDate utp3MonthsArrearsBreachStartDt = OptionalDate.empty();\\n    private OptionalDate utp3MonthsArrearsBreachEndDt = OptionalDate.empty();\\n    private String utpMultitudeArrangements;\\n    private OptionalDate utpMultitudeArrangementStartDt = OptionalDate.empty();\\n    private OptionalDate utpMultitudeArrangementEndDt = OptionalDate.empty();\\n    private String utpPersonalGuarantee;\\n    private OptionalDate utpPersonalGuaranteeStartDt = OptionalDate.empty();\\n    private OptionalDate utpPersonalGuaranteeEndDt = OptionalDate.empty();\\n    private String utpNotWillOrAble;\\n    private OptionalDate utpNotWillOrAbleStartDt = OptionalDate.empty();\\n    private OptionalDate utpNotWillOrAbleEndDt = OptionalDate.empty();\\n    private String utpFraud;\\n    private OptionalDate utpFraudStartDt = OptionalDate.empty();\\n    private OptionalDate utpFraudEndDt = OptionalDate.empty();\\n    private String utpLocInd1Name;\\n    private String utpLocInd1;\\n    private OptionalDate utpLocInd1StartDt = OptionalDate.empty();\\n    private OptionalDate utpLocInd1EndDt = OptionalDate.empty();\\n    private String utpLocInd2Name;\\n    private String utpLocInd2;\\n    private OptionalDate utpLocInd2StartDt = OptionalDate.empty();\\n    private OptionalDate utpLocInd2EndDt = OptionalDate.empty();\\n    private String utpLocInd3Name;\\n    private String utpLocInd3;\\n    private OptionalDate utpLocInd3StartDt = OptionalDate.empty();\\n    private OptionalDate utpLocInd3EndDt = OptionalDate.empty();\\n    private String utpLocInd4Name;\\n    private String utpLocInd4;\\n    private OptionalDate utpLocInd4StartDt = OptionalDate.empty();\\n    private OptionalDate utpLocInd4EndDt = OptionalDate.empty();\\n    private String utpLocInd5Name;\\n    private String utpLocInd5;\\n    private OptionalDate utpLocInd5StartDt = OptionalDate.empty();\\n    private OptionalDate utpLocInd5EndDt = OptionalDate.empty();\\n    private String mdlCode;\\n    private String submdlCode;\\n    private String mdlVer;\\n    private String mdlScore;\\n    private String pdRiskDrv1Val;\\n    private String pdRiskDrv2Val;\\n    private String pdRiskDrv3Val;\\n    private String pdRiskDrv4Val;\\n    private String pdRiskDrv5Val;\\n    private String pdRiskDrv6Val;\\n    private String pdRiskDrv7Val;\\n    private String pdRiskDrv8Val;\\n    private String pdRiskDrv9Val;\\n    private String pdRiskDrv10Val;\\n    private String pdRiskDrv11Val;\\n    private String pdRiskDrv12Val;\\n    private String pdRiskDrv13Val;\\n    private String pdRiskDrv14Val;\\n    private String pdRiskDrv15Val;\\n    private String pdRiskDrv16Val;\\n    private String pdRiskDrv17Val;\\n    private String pdRiskDrv18Val;\\n    private String pdRiskDrv19Val;\\n    private String pdRiskDrv20Val;\\n    private String pdRiskDrv21Val;\\n    private String pdRiskDrv22Val;\\n    private String pdRiskDrv23Val;\\n    private String pdRiskDrv24Val;\\n    private String pdRiskDrv25Val;\\n    private String pdRiskDrv26Val;\\n    private String pdRiskDrv27Val;\\n    private String pdRiskDrv28Val;\\n    private String pdRiskDrv29Val;\\n    private String pdRiskDrv30Val;\\n    private String pdRiskDrv31Val;\\n    private String pdRiskDrv32Val;\\n    private String pdRiskDrv33Val;\\n    private String pdRiskDrv34Val;\\n    private String pdRiskDrv35Val;\\n    private String pdRiskDrv36Val;\\n    private String pdRiskDrv37Val;\\n    private String pdRiskDrv38Val;\\n    private String pdRiskDrv39Val;\\n    private String pdRiskDrv40Val;\\n    private String pdRiskDrv41Val;\\n    private String pdRiskDrv42Val;\\n    private String pdRiskDrv43Val;\\n    private String pdRiskDrv44Val;\\n    private String pdRiskDrv45Val;\\n    private String pdRiskDrv46Val;\\n    private String pdRiskDrv47Val;\\n    private String pdRiskDrv48Val;\\n    private String pdRiskDrv49Val;\\n    private String pdRiskDrv50Val;\\n    private String pdRiskDrv51Val;\\n    private String pdRiskDrv52Val;\\n    private String pdRiskDrv53Val;\\n    private String pdRiskDrv54Val;\\n    private String pdRiskDrv55Val;\\n    private String utpForbearanceInd;\\n    private OptionalDate utpForbearanceIndStartDt = OptionalDate.empty();\\n    private OptionalDate utpForbearanceIndEndDt = OptionalDate.empty();\\n    private OptionalDate utpForbearanceIndDt = OptionalDate.empty();\\n    private String incorrectDfltReason;\\n    private OptionalDate incorrectDfltStartDt = OptionalDate.empty();\\n    private OptionalDate incorrectDfltEndDt = OptionalDate.empty();\\n    private String utpConnectedClient;\\n    private OptionalDate utpConnectedClientStartDt = OptionalDate.empty();\\n    private OptionalDate utpConnectedClientEndDt = OptionalDate.empty();\\n    private boolean gen = false;\\n}\\n\\n// Context API:\\nimport com.example.dq.foundation.data.MonetaryValue;\\nimport com.example.dq.foundation.data.OptionalDate;\\nimport lombok.Getter;\\nimport lombok.Setter;\\nimport lombok.ToString;\\n\\nimport java.math.BigDecimal;\\n\\n@Getter\\n@Setter\\n@ToString\\npublic final class SecuritisedLimit implements Sp4ConsumerEntity {\\n    private Long pk;\\n    private String secCode;\\n    private String locCustId;\\n    private String highLvlLmtId;\\n    private String lmtId;\\n    private Limit lmt;\\n    private MonetaryValue secAmt;\\n    private BigDecimal secPct;\\n    private boolean gen = false;\\n}\\n\\n// Context API:\\npublic interface TransformationRule<T, U extends DqContext> extends ExecutionBlock<T, U> {\\n    default void execute(T item, U context) {\\n        if (predicate(context).test(item)) {\\n            DataQualityEvent event = transformation(context).apply(item);\\n            context.getEventService().processEvent(event);\\n        }\\n    }\\n\\n    default Function<T, DataQualityEvent> exceptionRaisedEventTransformation(DqContext context) {\\n        return entity -> context.getEventService().createExceptionRaisedEvent(eventCode(), entity);\\n    }\\n\\n    Predicate<T> predicate(U context);\\n\\n    Function<T, DataQualityEvent> transformation(U context);\\n\\n    String eventCode();\\n}\"},{\"role\":\"user\",\"content\":\"                Convert the following PL/SQL to Java while respecting these rules:\\nMatch the patterns from these examples:\\nOnly use APIs from the provided context:\\n                \\n                Example 1:\\nPL/SQL:\\nINSERT INTO EXCEPTION (SYS_IDENTIFIER,\\n                       REPORT_DATE,\\n                       EXC_CATEGORY,\\n                       EXC_TYPE,\\n                       EXC_CODE,\\n                       ACT_CODE,\\n                       SOL_CODE,\\n                       LOCAL_CUST_ID,\\n                       FAC_ID,\\n                       COV_ID,\\n                       OUT_ID,\\n                       LOC_VALUE,\\n                       CRM_VALUE,\\n                       ADD_INFO,\\n                       ROW_IDENTIFIER)\\nSELECT DISTINCT v_sys_identifier,\\n                v_report_date,\\n                v_exc_category,\\n                v_exc_type,\\n                v_exc_code,\\n                v_act_code,\\n                v_sol_code,\\n                rf.local_cust_id,   --customer_id\\n                rf.fac_id,          --facility_id\\n                NULL,               --cover_id\\n                NULL,               --outstanding_id\\n                rf.ead_ifr9_ccy,    --local\\n                v_def_currency,     --crm\\n                'ead_ifr9_ccy defaulted to ' || v_def_currency, --additional\\n                rf.raw_fac_id       --rowid\\nFROM pp_fac_ead rf\\nWHERE rf.ead_ifr9_ccy IS NULL\\n  AND rf.ead_ifr9 IS NOT NULL;\\n\\nv_debug_msg := 40238plsql_line || ' Of PLSQL UNIT ' || 40238plsql_unit || ' rows affected: ' || SQL%rowcount;\\nutilities.show_debug(v_debug_msg);\\nCOMMIT;\\n\\n-- Defaulting the ead_ifr9_ccy\\nUPDATE pp_fac_ead\\nSET ead_ifr9_ccy = v_def_currency\\nWHERE ead_ifr9_ccy IS NULL\\n  AND ead_ifr9 IS NOT NULL;\\n\\nCOMMIT;\\n\\nJava:\\npackage com.example.dq.sp4.consumer.rules.limit.exposure_at_default_for_ifrs9;\\n\\nimport com.example.dq.foundation.data.MonetaryValue;\\nimport com.example.dq.foundation.events.DataQualityEvent;\\nimport com.example.dq.sp4.consumer.glue.ConsumerDqContext;\\nimport com.example.dq.sp4.consumer.glue.ConsumerTransformationRule;\\nimport itrf.vortex.spdi.entities.consumer.Limit;\\n\\nimport java.util.Optional;\\nimport java.util.function.Function;\\nimport java.util.function.Predicate;\\n\\n/**\\n * EAD For IFRS9 Currency is defaulted to system default value.\\n *\\n * <p><b>Rationale</b>: Standard currency conversion mapping exception</p>\\n *\\n * <p><b>Trigger</b>: This exception is raised if EAD for IFRS9 Currency cannot be mapped to a Vortex code. It is then defaulted to the defined default value per system.</p>\\n *\\n * <p><b>Transformation</b>: Raises the LIM_EIFR9CCYRDF_DEFAULTED event and sets the EAD For IFRS9 Currency to default value</p>\\n */\\npublic class LIM_EIFR9CCYRDF_DEFAULTED implements ConsumerTransformationRule<Limit> {\\n    @Override\\n    public Predicate<Limit> predicate(ConsumerDqContext context) {\\n        return eadIfr9AmountDelivered()\\n                .and(eadIfr9CurrencyIsNotValid());\\n    }\\n\\n    @Override\\n    public Function<Limit, DataQualityEvent> transformation(ConsumerDqContext context) {\\n        return limit -> {\\n            String originalValue = limit.getEadIfr9().currency();\\n            String defaultedValue = context.getEnrichmentService().getDefault(currency).vortexReference();\\n            limit.setEadIfr9(new MonetaryValue(defaultedValue, limit.getEadIfr9().value()));\\n            return context.getEventService().createFieldModifiedEvent(\\n                    eventCode(),\\n                    limit,\\n                    originalValue,\\n                    defaultedValue\\n            );\\n        };\\n    }\\n\\n    @Override\\n    public String eventCode() {\\n        return LIM_EIFR9CCYRDF_DEFAULTED;\\n    }\\n\\n    private Predicate<Limit> eadIfr9CurrencyIsNotValid() {\\n        return limit -> Optional.ofNullable(limit.getEadIfr9())\\n                .map(eadIfr9 -> eadIfr9.currency() == null)\\n                .orElse(false);\\n    }\\n\\n    private Predicate<Limit> eadIfr9AmountDelivered() {\\n        return limit -> Optional.ofNullable(limit.getEadIfr9())\\n                .map(eadIfr9 -> eadIfr9.value() != null)\\n                .orElse(false);\\n    }\\n}\\n\\nExample 2:\\nPL/SQL:\\nv_exc_code := 'FORMS1SDPOP';\\nv_exc_category := 'LIM';\\nv_sol_code := 'NIL';\\n\\nget_exception_info(\\n    v_sys_identifier        => v_sys_identifier,\\n    v_exc_code              => v_exc_code,\\n    v_exc_category          => v_exc_category,\\n    iv_sol_code             => v_sol_code,\\n    v_exc_type              => v_exc_type,\\n    v_act_code              => v_act_code,\\n    v_is_active             => v_is_active\\n);\\n\\nIF (v_is_active = 'Y') THEN\\n    INSERT INTO exceptions\\n        (sys_identifier,\\n         report_date,\\n         exc_category,\\n         exc_type,\\n         exc_code,\\n         act_code,\\n         sol_code,\\n         cust_id,\\n         high_level_fac_id,\\n         cov_id,\\n         fac_id,\\n         loc_value,\\n         crm_value,\\n         add_info,\\n         row_identifier)\\n    SELECT v_sys_identifier,\\n           v_report_date,\\n           v_exc_category,\\n           v_exc_type,\\n           v_exc_code,\\n           v_act_code,\\n           v_sol_code,\\n           rl.cust_id,               --customer_id\\n           rl.high_level_fac_id,     --higher_level_facility_id\\n           NULL,                     --cover_id\\n           rl.fac_id,                --facility_id\\n           rl.forb_meas_start_date,  --local value\\n           NULL,                     --crm value\\n           'forbearance measure start date set to null when forbearance measure is not available', --additional information\\n           NULL                      --record_id\\n    FROM raw_limit rl\\n    WHERE rl.forb_meas_start_date IS NOT NULL\\n      AND rl.forbearance_meas IS NULL\\n      AND rl.dummy_ind IS NULL;\\n    COMMIT;\\n\\n    -- Default forbearance_start_date to NULL\\n    BEGIN\\n        UPDATE raw_limit rl\\n        SET rl.forb_meas_start_date = NULL\\n        WHERE rl.forb_meas_start_date IS NOT NULL\\n          AND rl.forbearance_meas IS NULL;\\n\\n    EXCEPTION WHEN OTHERS THEN\\n        dbms_output.put_line('ERROR: Failed to default forb_meas_start_date for LIM_FORMS1SDPOP_DEFAULTED');\\n        utils.handleerror(sqlcode, sqlerrm);\\n    END;\\nEND IF;\\n\\nJava:\\npackage com.example.dq.sp4.consumer.rules.limit.forbearance_measure_1_start_date;\\n\\nimport com.example.dq.foundation.data.OptionalDate;\\nimport com.example.dq.foundation.events.DataQualityEvent;\\nimport com.example.dq.sp4.consumer.glue.ConsumerDqContext;\\nimport com.example.dq.sp4.consumer.glue.ConsumerTransformationRule;\\nimport itrf.vortex.spdi.entities.consumer.Limit;\\n\\nimport java.util.function.Function;\\nimport java.util.function.Predicate;\\n\\n/**\\n * Forbearance Measure 1 Start Date is delivered but Forbearance Measure 1 is not populated. Forbearance Measure 1 Start Date is defaulted to NULL (empty).\\n *\\n * <p><b>Rationale</b>: Forbearance Measure 1 Start Date is only expected when Forbearance Measure 1 is populated (either delivered or defaulted).</p>\\n *\\n * <p><b>Trigger</b>: This exception is raised if:</p>\\n * <ul>\\n *     <li>Forbearance Measure Start Date is delivered</li>\\n *     <li>and Forbearance Measure 1 is not populated (final value).</li>\\n * </ul>\\n *\\n * <p><b>Transformation</b>: Raises the LIM_FORMS1SDPOP_NIL event and sets the forbearance measure 1 start date to null</p>\\n */\\npublic class LIM_FORMS1SDPOP_NIL implements ConsumerTransformationRule<Limit> {\\n    @Override\\n    public Predicate<Limit> predicate(ConsumerDqContext context) {\\n        return forbMeasStartDateDelivered()\\n                .and(forbMeasNotPopulated());\\n    }\\n\\n    public Predicate<Limit> forbMeasStartDateDelivered() {\\n        return limit -> limit.getForbMeasStartDate().isPresent();\\n    }\\n\\n    public Predicate<Limit> forbMeasNotPopulated() {\\n        return limit -> limit.getForbMeas() == null;\\n    }\\n\\n    @Override\\n    public Function<Limit, DataQualityEvent> transformation(ConsumerDqContext context) {\\n        return limit -> {\\n            OptionalDate previousValue = limit.getForbMeasStartDate();\\n            limit.setForbMeasStartDate(OptionalDate.empty());\\n            return context.getEventService().createFieldModifiedEvent(\\n                    eventCode(),\\n                    limit,\\n                    previousValue,\\n                    limit.getForbMeasStartDate()\\n            );\\n        };\\n    }\\n\\n    @Override\\n    public String eventCode() {\\n        return LIM_FORMS1SDPOP_NIL;\\n    }\\n}\\n\\nExample 3:\\nPL/SQL:\\nv_exc_code := 'FORMS2SDPOP';\\nv_exc_category := 'LIM';\\nv_sol_code := 'NIL';\\n\\nget_exception_info(\\n    v_sys_identifier        => v_sys_identifier,\\n    v_exc_code              => v_exc_code,\\n    v_exc_category          => v_exc_category,\\n    iv_sol_code             => v_sol_code,\\n    v_exc_type              => v_exc_type,\\n    v_act_code              => v_act_code,\\n    v_is_active             => v_is_active\\n);\\n\\nIF (v_is_active = 'Y') THEN\\n    INSERT INTO exceptions\\n        (sys_identifier,\\n         report_date,\\n         exc_category,\\n         exc_type,\\n         exc_code,\\n         act_code,\\n         sol_code,\\n         cust_id,\\n         high_level_fac_id,\\n         cov_id,\\n         fac_id,\\n         loc_value,\\n         crm_value,\\n         add_info,\\n         row_identifier)\\n    SELECT v_sys_identifier,\\n           v_report_date,\\n           v_exc_category,\\n           v_exc_type,\\n           v_exc_code,\\n           v_act_code,\\n           v_sol_code,\\n           rl.cust_id,                --customer_id\\n           rl.high_level_fac_id,      --higher_level_facility_id\\n           NULL,                      --cover_id\\n           rl.fac_id,                 --facility_id\\n           rl.forb_meas_start_date_2, --local value\\n           NULL,                      --crm value\\n           'forb_meas_start_date_2 set to null when forb_meas_2 is not available', --additional information\\n           NULL                       --record_id\\n    FROM raw_limit rl\\n    WHERE rl.forb_meas_start_date_2 IS NOT NULL\\n      AND rl.forb_meas_2 IS NULL\\n      AND rl.dummy_ind IS NULL;\\n    COMMIT;\\n\\n    -- Default forbearance_start_date_2 to NULL\\n    BEGIN\\n        UPDATE raw_limit rl\\n        SET rl.forb_meas_start_date_2 = NULL\\n        WHERE rl.forb_meas_start_date_2 IS NOT NULL\\n          AND rl.forb_meas_2 IS NULL;\\n\\n    EXCEPTION WHEN OTHERS THEN\\n        dbms_output.put_line('ERROR: Failed to default forb_meas_start_date_2 for LIM_FORMS2SDPOP_DEFAULTED');\\n        utils.handleerror(sqlcode, sqlerrm);\\n    END;\\n\\n    utilities.show_debug(40238plsql_line || 'OF PLSQL UNIT' || 40238plsql_unit || ' ' || ' affected rows: ' || SQL%rowcount);\\n    COMMIT;\\nEND IF;\\n\\nJava:\\npackage com.example.dq.sp4.consumer.rules.limit.forbearance_measure_1_start_date;\\n\\nimport com.example.dq.foundation.data.OptionalDate;\\nimport com.example.dq.foundation.events.DataQualityEvent;\\nimport com.example.dq.sp4.consumer.glue.ConsumerDqContext;\\nimport com.example.dq.sp4.consumer.glue.ConsumerTransformationRule;\\nimport itrf.vortex.spdi.entities.consumer.Limit;\\n\\nimport java.util.function.Function;\\nimport java.util.function.Predicate;\\n\\n/**\\n * Forbearance Measure 1 Start Date is delivered but Forbearance Measure 1 is not populated. Forbearance Measure 1 Start Date is defaulted to NULL (empty).\\n *\\n * <p><b>Rationale</b>: Forbearance Measure 1 Start Date is only expected when Forbearance Measure 1 is populated (either delivered or defaulted).</p>\\n *\\n * <p><b>Trigger</b>: This exception is raised if:</p>\\n * <ul>\\n *     <li>Forbearance Measure Start Date is delivered</li>\\n *     <li>and Forbearance Measure 1 is not populated (final value).</li>\\n * </ul>\\n *\\n * <p><b>Transformation</b>: Raises the LIM_FORMS1SDPOP_NIL event and sets the forbearance measure 1 start date to null</p>\\n */\\npublic class LIM_FORMS1SDPOP_NIL implements ConsumerTransformationRule<Limit> {\\n    @Override\\n    public Predicate<Limit> predicate(ConsumerDqContext context) {\\n        return forbMeasStartDateDelivered()\\n                .and(forbMeasNotPopulated());\\n    }\\n\\n    public Predicate<Limit> forbMeasStartDateDelivered() {\\n        return limit -> limit.getForbMeasStartDate().isPresent();\\n    }\\n\\n    public Predicate<Limit> forbMeasNotPopulated() {\\n        return limit -> limit.getForbMeas() == null;\\n    }\\n\\n    @Override\\n    public Function<Limit, DataQualityEvent> transformation(ConsumerDqContext context) {\\n        return limit -> {\\n            OptionalDate previousValue = limit.getForbMeasStartDate();\\n            limit.setForbMeasStartDate(OptionalDate.empty());\\n            return context.getEventService().createFieldModifiedEvent(\\n                    eventCode(),\\n                    limit,\\n                    previousValue,\\n                    limit.getForbMeasStartDate()\\n            );\\n        };\\n    }\\n\\n    @Override\\n    public String eventCode() {\\n        return \\\"LIM_FORMS1SDPOP_NIL\\\";\\n    }\\n}\\n                \\n                Target PL/SQL to convert:\\n                v_description := 'create exceptions for code: ' || v_exc_code || ', exception category: ' || v_exc_category;\\nutilities.show_debug(v_proc_name || 'info => ' || v_description);\\n\\nINSERT /*+ APPEND enable_parallel_dml */\\n  INTO exceptions (sys_identifier,\\n                   report_date,\\n                   exc_category,\\n                   exc_type,\\n                   exc_code,\\n                   act_code,\\n                   sol_code,\\n                   cust_id,\\n                   cov_id,\\n                   fac_id,\\n                   loc_value,\\n                   crm_value,\\n                   add_info,\\n                   row_identifier)\\nSELECT  /*+ PARALLEL +*/\\n       DISTINCT\\n       v_sys_identifier,\\n       v_report_date,\\n       v_exc_category,\\n       v_exc_type,\\n       v_exc_code,\\n       v_act_code,\\n       v_sol_code,\\n       rl.cust_id,                                                   --customer_id\\n       NULL,                                                         --cover_id\\n       rl.fac_id,                                                    --facility_id\\n       rl.ead_regcap_ccy,                                            --local value\\n       v_def_currency,                                               --crm value\\n       'ead_regcap_ccy defaulted to ' || v_def_currency,             --additional information\\n       NULL                                                          --record_id\\nFROM RAW_LIMIT rl\\nWHERE rl.ead_regcap_ccy IS NULL\\n  AND rl.ead_regcap IS NOT NULL;\\n\\nv_debug_msg := 40238plsql_line || ' Of PLSQL UNIT ' || 40238plsql_unit || ' rows affected: ' || SQL%rowcount;\\nutilities.show_debug(v_debug_msg);\\nCOMMIT;\\n\\n-- Defaulting the ead_regcap_ccy\\nUPDATE RAW_LIMIT\\nSET ead_regcap_ccy = v_def_currency\\nWHERE ead_regcap_ccy IS NULL\\n  AND ead_regcap IS NOT NULL;\\n\\nCOMMIT;\\n\"}],\"model\":\"deepseek-chat\",\"temperature\":0.2}",
      "ignoreArrayOrder" : true,
      "ignoreExtraElements" : true
    } ]
  },
  "response" : {
    "status" : 200,
    "body" : "{\"id\":\"08366dd0-f824-45fd-ae48-47a16b9f2dcb\",\"object\":\"chat.completion\",\"created\":1738194158,\"model\":\"deepseek-chat\",\"choices\":[{\"index\":0,\"message\":{\"role\":\"assistant\",\"content\":\"Here is the Java conversion of the provided PL/SQL code, following the patterns and rules specified:\\n\\n```java\\npackage com.example.dq.sp4.consumer.rules.limit.exposure_at_default_for_regcap;\\n\\nimport com.example.dq.foundation.data.MonetaryValue;\\nimport com.example.dq.foundation.events.DataQualityEvent;\\nimport com.example.dq.sp4.consumer.glue.ConsumerDqContext;\\nimport com.example.dq.sp4.consumer.glue.ConsumerTransformationRule;\\nimport itrf.vortex.spdi.entities.consumer.Limit;\\n\\nimport java.util.Optional;\\nimport java.util.function.Function;\\nimport java.util.function.Predicate;\\n\\n/**\\n * EAD For RegCap Currency is defaulted to system default value.\\n *\\n * <p><b>Rationale</b>: Standard currency conversion mapping exception</p>\\n *\\n * <p><b>Trigger</b>: This exception is raised if EAD for RegCap Currency cannot be mapped to a Vortex code. It is then defaulted to the defined default value per system.</p>\\n *\\n * <p><b>Transformation</b>: Raises the LIM_EADREGCAPCCY_DEFAULTED event and sets the EAD For RegCap Currency to default value</p>\\n */\\npublic class LIM_EADREGCAPCCY_DEFAULTED implements ConsumerTransformationRule<Limit> {\\n\\n    @Override\\n    public Predicate<Limit> predicate(ConsumerDqContext context) {\\n        return eadRegCapAmountDelivered()\\n                .and(eadRegCapCurrencyIsNotValid());\\n    }\\n\\n    @Override\\n    public Function<Limit, DataQualityEvent> transformation(ConsumerDqContext context) {\\n        return limit -> {\\n            String originalValue = limit.getEadRegcap().currency();\\n            String defaultedValue = context.getEnrichmentService().getDefault(\\\"currency\\\").vortexReference();\\n            limit.setEadRegcap(new MonetaryValue(defaultedValue, limit.getEadRegcap().value()));\\n            return context.getEventService().createFieldModifiedEvent(\\n                    eventCode(),\\n                    limit,\\n                    originalValue,\\n                    defaultedValue\\n            );\\n        };\\n    }\\n\\n    @Override\\n    public String eventCode() {\\n        return \\\"LIM_EADREGCAPCCY_DEFAULTED\\\";\\n    }\\n\\n    private Predicate<Limit> eadRegCapCurrencyIsNotValid() {\\n        return limit -> Optional.ofNullable(limit.getEadRegcap())\\n                .map(eadRegcap -> eadRegcap.currency() == null)\\n                .orElse(false);\\n    }\\n\\n    private Predicate<Limit> eadRegCapAmountDelivered() {\\n        return limit -> Optional.ofNullable(limit.getEadRegcap())\\n                .map(eadRegcap -> eadRegcap.value() != null)\\n                .orElse(false);\\n    }\\n}\\n```\\n\\n### Explanation:\\n1. **Predicate**: \\n   - `eadRegCapAmountDelivered()` checks if the `eadRegcap` amount is delivered (i.e., not null).\\n   - `eadRegCapCurrencyIsNotValid()` checks if the `eadRegcap` currency is not valid (i.e., null).\\n\\n2. **Transformation**:\\n   - The transformation function retrieves the default currency from the `ConsumerDqContext` using the `getDefault` method.\\n   - It then updates the `eadRegcap` currency to the default value and raises a `FieldModifiedEvent` to log the change.\\n\\n3. **Event Code**:\\n   - The event code `LIM_EADREGCAPCCY_DEFAULTED` is used to identify this specific transformation rule.\\n\\n4. **Error Handling**:\\n   - The transformation rule implicitly handles errors by ensuring that the `eadRegcap` field is only modified if the conditions in the predicate are met.\\n\\nThis Java code maintains functional equivalence with the provided PL/SQL code while adhering to Java best practices and using the provided context APIs.\"},\"logprobs\":null,\"finish_reason\":\"stop\"}],\"usage\":{\"prompt_tokens\":13566,\"completion_tokens\":831,\"total_tokens\":14397,\"prompt_tokens_details\":{\"cached_tokens\":13504},\"prompt_cache_hit_tokens\":13504,\"prompt_cache_miss_tokens\":62},\"system_fingerprint\":\"fp_3a5770e1b4\"}",
    "headers" : {
      "CF-RAY" : "909d1469d8456614-AMS",
      "Server" : "cloudflare",
      "vary" : [ "origin, access-control-request-method, access-control-request-headers", "accept-encoding" ],
      "cf-cache-status" : "DYNAMIC",
      "strict-transport-security" : "max-age=31536000; includeSubDomains; preload",
      "Date" : "Wed, 29 Jan 2025 23:42:38 GMT",
      "access-control-allow-credentials" : "true",
      "x-content-type-options" : "nosniff",
      "x-ds-trace-id" : "7bb65afe110c29b1cdb67d6a4d0c6e64",
      "Set-Cookie" : [ "HWWAFSESTIME=1738194154669; path=/", "HWWAFSESID=50dd81ae9987680b8f0; path=/", "__cf_bm=ELymRFUJfPxH0ZFSw.KjE8COUEoZ_MHY0UUTTjnwfo4-1738194158-1.0.1.1-MDa9T9LrkAWyxekwFIWhVhJGpLroQxg8P0F8Q6kK9Zw_yWOHbG5d_BjJ8xPp6wmGOW9AH3WVsTtJBF4Oc_M5Zw; path=/; expires=Thu, 30-Jan-25 00:12:38 GMT; domain=.deepseek.com; HttpOnly; Secure; SameSite=None" ],
      "Content-Type" : "application/json"
    }
  },
  "uuid" : "0e9a87ff-b62e-4661-a0da-8b8a98a5c4b4",
  "persistent" : true,
  "insertionIndex" : 3
}