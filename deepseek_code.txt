File: ./README.md

## Set up your environment
```
export DEEPSEEK_API_KEY=your_api_key
```

## Running the application
```
mvn clean spring-boot:run
```

Then call the API:
```
curl localhost:8080/generate/1
```

### Running with 1Password integration
To not have to manually set the environment variables, you can use 1Password integration to set
them at runtime.

```
op run --env-file="./secrets.env" -- mvn clean spring-boot:run
```
========================================================================

File: ./pom.xml

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.4.1</version>
        <relativePath/>
    </parent>

    <groupId>org.bullit</groupId>
    <artifactId>dsictwi</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>DeepSeek ICTwI</name>

    <properties>
        <kotlin.version>2.0.21</kotlin.version>
        <arrow.version>2.0.0</arrow.version>
		<wiremock.version>3.10.0</wiremock.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>
        <dependency>
			<groupId>com.fasterxml.jackson.module</groupId>
			<artifactId>jackson-module-kotlin</artifactId>
		</dependency>
		<dependency>
			<groupId>io.projectreactor.kotlin</groupId>
			<artifactId>reactor-kotlin-extensions</artifactId>
		</dependency>
		<dependency>
			<groupId>org.jetbrains.kotlin</groupId>
			<artifactId>kotlin-reflect</artifactId>
		</dependency>
		<dependency>
			<groupId>org.jetbrains.kotlin</groupId>
			<artifactId>kotlin-stdlib-jdk8</artifactId>
		</dependency>
		<dependency>
			<groupId>org.jetbrains.kotlinx</groupId>
			<artifactId>kotlinx-coroutines-reactor</artifactId>
		</dependency>
		<dependency>
			<groupId>org.jetbrains.kotlinx</groupId>
			<artifactId>kotlinx-coroutines-jdk8</artifactId>
		</dependency>
		<dependency>
			<groupId>io.arrow-kt</groupId>
			<artifactId>arrow-core-jvm</artifactId>
			<version>${arrow.version}</version>
		</dependency>
		<dependency>
			<groupId>io.arrow-kt</groupId>
			<artifactId>arrow-fx-coroutines-jvm</artifactId>
			<version>${arrow.version}</version>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>io.projectreactor</groupId>
			<artifactId>reactor-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.wiremock</groupId>
			<artifactId>wiremock-standalone</artifactId>
			<version>${wiremock.version}</version>
			<scope>test</scope>
		</dependency>
    </dependencies>

    <profiles>
		<profile>
			<id>netty-resolver-dns-native-macos-aarch64</id>
			<activation>
				<os>
					<family>mac</family>
					<arch>aarch64</arch>
				</os>
			</activation>
			<dependencies>
				<dependency>
					<groupId>io.netty</groupId>
					<artifactId>netty-resolver-dns-native-macos</artifactId>
					<classifier>osx-aarch_64</classifier>
				</dependency>
			</dependencies>
		</profile>
    </profiles>

    <build>
		<sourceDirectory>${project.basedir}/src/main/kotlin</sourceDirectory>
		<testSourceDirectory>${project.basedir}/src/test/kotlin</testSourceDirectory>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
			<plugin>
				<groupId>org.jetbrains.kotlin</groupId>
				<artifactId>kotlin-maven-plugin</artifactId>
				<configuration>
					<args>
						<arg>-Xjsr305=strict</arg>
					</args>
					<compilerPlugins>
						<plugin>spring</plugin>
					</compilerPlugins>
				</configuration>
				<dependencies>
					<dependency>
						<groupId>org.jetbrains.kotlin</groupId>
						<artifactId>kotlin-maven-allopen</artifactId>
						<version>${kotlin.version}</version>
					</dependency>
				</dependencies>
			</plugin>
		</plugins>
	</build>
</project>
========================================================================

File: ./secrets.env

DEEPSEEK_API_KEY="op://Personal/Deepseek/ictwi api key"

========================================================================

File: ./src/main/kotlin/org/bullit/dsictwi/CodeGenController.kt

package org.bullit.dsictwi

import arrow.core.Either
import arrow.core.nel
import arrow.core.raise.either
import org.bullit.dsictwi.error.ApplicationErrors
import org.bullit.dsictwi.error.InvalidInputNumber
import org.bullit.dsictwi.error.joinMessages
import org.bullit.dsictwi.prompts.CodeReader
import org.bullit.dsictwi.prompts.DeepSeekClient
import org.bullit.dsictwi.prompts.PromptBuilder
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RestController

@RestController
class CodeGenController(
    private val codeReader: CodeReader,
    private val promptBuilder: PromptBuilder,
    private val deepSeekClient: DeepSeekClient
) {
    @GetMapping("/generate/{number}")
    suspend fun generateCode(@PathVariable number: Int) = either {
        if (number !in 1..10) raise(InvalidInputNumber(number).nel())

        val codePairs = codeReader.getCodePairs().bind()

        val (examples, target) = codePairs.extractElementAt(number - 1)

        val context = codeReader.getContextJava().bind()

        val systemMessage = promptBuilder.buildSystemPrompt(context)
        val userMessage = promptBuilder.buildUserPrompt(examples, target.plsql)

        deepSeekClient.generateCode(listOf(systemMessage, userMessage)).bind()
    }.toHttpResponse()

    fun <T> List<T>.extractElementAt(index: Int): Pair<List<T>, T> =
        when (index) {
            0 -> subList(1, size) to first()
            lastIndex -> subList(0, lastIndex) to last()
            else -> (subList(0, index) + subList(index + 1, size)) to this[index]
        }

    private fun <T> Either<ApplicationErrors, T>.toHttpResponse() =
        fold(
            ifLeft = {
                ResponseEntity(it.joinMessages(), HttpStatus.BAD_REQUEST)
            },
            ifRight = {
                ResponseEntity(it, HttpStatus.OK)
            }
        )
}
========================================================================

File: ./src/main/kotlin/org/bullit/dsictwi/DeepSeekIctwiApplication.kt

package org.bullit.dsictwi

import org.bullit.dsictwi.config.DeepSeekConfig
import org.bullit.dsictwi.config.PromptConfig
import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.context.properties.EnableConfigurationProperties
import org.springframework.boot.runApplication

@EnableConfigurationProperties(DeepSeekConfig::class, PromptConfig::class)
@SpringBootApplication
class DeepSeekIctwiApplication

fun main(args: Array<String>) {
	runApplication<DeepSeekIctwiApplication>(*args)
}

========================================================================

File: ./src/main/kotlin/org/bullit/dsictwi/Util.kt

package org.bullit.dsictwi

import arrow.core.*
import kotlinx.coroutines.reactive.awaitFirstOrElse
import org.bullit.dsictwi.error.ApiError
import org.bullit.dsictwi.error.ApplicationErrors
import org.bullit.dsictwi.error.ApplicationError
import reactor.core.publisher.Mono

suspend inline fun <reified T> Mono<T>.toEither(crossinline errorFun: (throwable: Throwable) -> ApplicationError): Either<ApplicationError, T> =
    map<Either<ApplicationError, T>> { it.right() }
        .onErrorResume { Mono.just(errorFun(it).left()) }
        .awaitFirstOrElse {
            when (Unit) {
                is T -> Unit.right() as Either<ApplicationError, T>
                else -> ApiError("No response").left()
            }
        }

fun <T> Either<ApplicationError, T>.toApplicationErrors(): Either<ApplicationErrors, T> =
    mapLeft { nonEmptyListOf(it) }

fun <T> List<Either<ApplicationErrors, T>>.flatten(): Either<ApplicationErrors, List<T>> =
    fold(
        initial = Pair(emptyList<ApplicationError>(), emptyList<T>())
    ) { (errors, values), either ->
        either.fold(
            ifLeft = { error ->
                Pair(errors + error, values)
            },
            ifRight = { value ->
                Pair(errors, values + value)
            }
        )
    }.let { (errors, values) ->
        errors.toNonEmptyListOrNull()?.left() ?: values.right()
    }
========================================================================

File: ./src/main/kotlin/org/bullit/dsictwi/config/DeepSeekConfig.kt

package org.bullit.dsictwi.config

import org.springframework.boot.context.properties.ConfigurationProperties

@ConfigurationProperties(prefix = "deepseek")
data class DeepSeekConfig(
    val apiKey: String,
    val model: String,
    val temperature: Double,
    val baseUrl: String,
    val chatUrl: String
)
========================================================================

File: ./src/main/kotlin/org/bullit/dsictwi/config/PromptConfig.kt

package org.bullit.dsictwi.config

import org.springframework.boot.context.properties.ConfigurationProperties

@ConfigurationProperties(prefix = "prompt")
data class PromptConfig(
    val system: SystemPromptConfig,
    val user: UserPromptConfig
) {
    data class SystemPromptConfig(
        val base: String,
        val rules: List<String>,
        val contextHeader: String
    )

    data class UserPromptConfig(
        val instructions: List<String>,
        val exampleFormat: String,
        val targetHeader: String
    )
}
========================================================================

File: ./src/main/kotlin/org/bullit/dsictwi/config/ResourceConfig.kt

package org.bullit.dsictwi.config

import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.core.io.ResourceLoader
import org.springframework.core.io.support.PathMatchingResourcePatternResolver
import org.springframework.core.io.support.ResourcePatternResolver

@Configuration
class ResourceConfig {

    @Bean
    fun resourcePatternResolver(resourceLoader: ResourceLoader): ResourcePatternResolver =
        PathMatchingResourcePatternResolver(resourceLoader)
}
========================================================================

File: ./src/main/kotlin/org/bullit/dsictwi/error/ApplicationError.kt

package org.bullit.dsictwi.error

import arrow.core.NonEmptyList

typealias ApplicationErrors = NonEmptyList<ApplicationError>

sealed interface ApplicationError {
    val message: String
    val throwable: Throwable?
}

abstract class AbstractApplicationError(
    override val message: String,
    override val throwable: Throwable? = null
) : ApplicationError {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as AbstractApplicationError

        if (message != other.message) return false
        return throwable == other.throwable
    }

    override fun hashCode(): Int {
        var result = message.hashCode()
        result = 31 * result + (throwable?.hashCode() ?: 0)
        return result
    }

    override fun toString(): String {
        return "${this::class.simpleName}(message='$message', throwable=$throwable)"
    }
}

class InvalidInputNumber(inputNumber: Int) : AbstractApplicationError(
    message = "Input number $inputNumber needs to be between 1 and 10"
)

class FileNotFound(filename: String, throwable: Throwable?) : AbstractApplicationError(
    message = "File $filename not found",
    throwable = throwable
)

class ApiError(message: String = "Error interacting with the DeepSeek API") : AbstractApplicationError(
    message = message
)

fun <T : ApplicationError> NonEmptyList<T>.joinMessages(separator: CharSequence = ", "): String =
    this.map { it }.joinToString(separator = separator)

========================================================================

File: ./src/main/kotlin/org/bullit/dsictwi/prompts/CodePair.kt

package org.bullit.dsictwi.prompts

data class CodePair(
    val plsql: String,
    val java: String
)
========================================================================

File: ./src/main/kotlin/org/bullit/dsictwi/prompts/CodeReader.kt

package org.bullit.dsictwi.prompts

import arrow.core.Either
import arrow.core.nel
import arrow.core.raise.catch
import arrow.core.raise.either
import org.bullit.dsictwi.error.ApplicationErrors
import org.bullit.dsictwi.error.FileNotFound
import org.bullit.dsictwi.flatten
import org.springframework.core.io.Resource
import org.springframework.core.io.support.ResourcePatternResolver
import org.springframework.stereotype.Service

@Service
class CodeReader(
    private val resourcePatternResolver: ResourcePatternResolver
) {
    fun getContextJava() = cachedContexts

    fun getCodePairs() = cachedCodePairs

    private val cachedContexts by lazy {
        loadContextsSafely()
    }

    private val cachedCodePairs by lazy {
        readCodePairs()
    }

    private fun loadContextsSafely(): Either<ApplicationErrors, List<String>> = either {
        catch({
            resourcePatternResolver.getResources("classpath*:context/*.txt")
                .sortedBy { it.filename }
                .map { it.readText() }
        }) { throwable ->
            raise(
                FileNotFound(
                    "Context file",
                    throwable
                ).nel()
            )
        }
    }

    private fun readCodePairs(): Either<ApplicationErrors, List<CodePair>> =
        (1..10)
            .map { readCodePair(it) }
            .flatten()

    private fun Resource.readText(): String =
        inputStream.bufferedReader().use { it.readText() }

    private fun readCodePair(number: Int): Either<ApplicationErrors, CodePair> = Either.catch {
        val plsql = readResource("plsql-$number.txt")
        val java = readResource("java-$number.txt")
        CodePair(plsql, java)
    }.mapLeft { FileNotFound("Pair $number", it).nel() }

    private fun readResource(filename: String): String =
        resourcePatternResolver
            .getResources("classpath:samples/$filename")[0]
            .inputStream
            .bufferedReader()
            .use { it.readText() }
}

========================================================================

File: ./src/main/kotlin/org/bullit/dsictwi/prompts/DeepSeekClient.kt

package org.bullit.dsictwi.prompts

import arrow.core.Either
import org.bullit.dsictwi.config.DeepSeekConfig
import org.bullit.dsictwi.error.ApiError
import org.bullit.dsictwi.error.ApplicationErrors
import org.bullit.dsictwi.toApplicationErrors
import org.bullit.dsictwi.toEither
import org.springframework.stereotype.Service
import org.springframework.web.reactive.function.client.WebClient
import reactor.core.publisher.Mono

@Service
class DeepSeekClient(
    private val config: DeepSeekConfig
) {
    private val webClient = WebClient
        .builder()
        .baseUrl(config.baseUrl)
        .defaultHeader("Authorization", "Bearer ${config.apiKey}")
        .build()

    suspend fun generateCode(messages: List<Message>): Either<ApplicationErrors, DeepSeekResponse> =
        generateCodeReactive(messages)
            .toEither { t -> ApiError(t.message ?: "Error interacting with DeepSeek API") }
            .toApplicationErrors()

    private fun generateCodeReactive(messages: List<Message>): Mono<DeepSeekResponse> {
        val request = DeepSeekRequest(
            messages = messages,
            model = config.model,
            temperature = config.temperature
        )

        return webClient
            .post()
            .uri(config.chatUrl)
            .bodyValue(request)
            .retrieve()
            .bodyToMono(DeepSeekResponse::class.java)
    }

    private data class DeepSeekRequest(
        val messages: List<Message>,
        val model: String,
        val temperature: Double
    )

    data class DeepSeekResponse(
        val choices: List<Choice>
    ) {
        data class Choice(
            val index: Int,
            val message: Message
        )
    }
}
========================================================================

File: ./src/main/kotlin/org/bullit/dsictwi/prompts/Message.kt

package org.bullit.dsictwi.prompts

data class Message(
    val role: String,
    val content: String
)
========================================================================

File: ./src/main/kotlin/org/bullit/dsictwi/prompts/PromptBuilder.kt

package org.bullit.dsictwi.prompts

import org.bullit.dsictwi.config.PromptConfig
import org.springframework.stereotype.Service

@Service
class PromptBuilder(private val config: PromptConfig) {

    fun buildSystemPrompt(contextJava: List<String>): Message =
        Message(
            "system",
            """
                ${config.system.base}
                
                Rules:
                ${config.system.rules.joinToString("\n") { "â€¢ $it" }}
                
                ${config.system.contextHeader}
                ${contextJava.joinToString("\n\n") { "// Context API:\n$it" }}
            """.trimIndent()
        )

    fun buildUserPrompt(examples: List<CodePair>, targetPlsql: String): Message {
        val examplesContent = examples.mapIndexed { index, pair ->
            config.user.exampleFormat.format(
                index + 1,
                pair.plsql.trim(),
                pair.java.trim()
            )
        }.joinToString("\n\n")

        return Message(
            "user",
            """
                ${config.user.instructions.joinToString("\n")}
                
                $examplesContent
                
                ${config.user.targetHeader}
                $targetPlsql
            """.trimIndent()
        )
    }
}
========================================================================

File: ./src/main/resources/application.yml

prompt:
  system:
    base: "You are a senior Java developer specializing in converting PL/SQL to maintainable Java code."
    rules:
      - "Use only provided context APIs"
      - "Maintain exact functional equivalence"
      - "Follow Java best practices"
      - "Never invent new APIs or field names, all the field names and functions that you need are present in the context that was passed"
      - "Include proper error handling"
      - "Predicates must only handle a single responsibility, so they can be combined using the predicate api in the top level predicate"
      - "Use modern Java features where appropriate"
    context-header: "Available Context APIs:"

  user:
    instructions:
      - "Convert the following PL/SQL to Java while respecting these rules:"
      - "Match the patterns from these examples:"
      - "Only use APIs from the provided context:"
    example-format: "Example %d:\nPL/SQL:\n%s\n\nJava:\n%s"
    target-header: "Target PL/SQL to convert:"

deepseek:
  api-key: ${DEEPSEEK_API_KEY}
  model: deepseek-chat
  temperature: 0.2
  base-url: https://api.deepseek.com
  chat-url: /chat/completions
========================================================================

File: ./src/test/kotlin/org/bullit/dsictwi/AbstractWiremockTest.kt

package org.bullit.dsictwi

import com.github.tomakehurst.wiremock.WireMockServer
import com.github.tomakehurst.wiremock.client.WireMock
import com.github.tomakehurst.wiremock.common.ConsoleNotifier
import com.github.tomakehurst.wiremock.core.WireMockConfiguration
import com.github.tomakehurst.wiremock.matching.RequestPatternBuilder
import com.github.tomakehurst.wiremock.recording.RecordSpec
import com.github.tomakehurst.wiremock.recording.RecordingStatus
import org.bullit.dsictwi.wiremock.WireMockProxy
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.BeforeEach

abstract class AbstractWiremockTest(
    private val proxy: WireMockProxy
) {
    private lateinit var wiremockServer: WireMockServer

    private val getMockServer: (WireMockProxy) -> WireMockServer = { proxy ->
        WireMockServer(
            WireMockConfiguration
                .options()
                .port(proxy.port)
                .withRootDirectory("src/test/resources")
                .notifier(ConsoleNotifier(true))
        )
    }

    @BeforeEach
    fun startRecording() {
        val wireMockServer = getMockServer(proxy)
        wireMockServer.start()
        if (proxy.recording) wireMockServer.startRecording(config(proxy.url))
        wiremockServer = wireMockServer
    }

    @AfterEach
    fun stopRecording() {
        if (wiremockServer.recordingStatus.status == RecordingStatus.Recording) wiremockServer.stopRecording()
        wiremockServer.stop()
    }

    private fun config(recordingURL: String): RecordSpec =
        WireMock.recordSpec()
            .forTarget(recordingURL)
            .onlyRequestsMatching(RequestPatternBuilder.allRequests())
            .captureHeader("Accept")
            .makeStubsPersistent(true)
            .build()
}
========================================================================

File: ./src/test/kotlin/org/bullit/dsictwi/CodeGenControllerIntegrationTest.kt

package org.bullit.dsictwi

import org.bullit.dsictwi.wiremock.WireMockProxy
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.autoconfigure.web.reactive.AutoConfigureWebTestClient
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.web.reactive.server.WebTestClient
import kotlin.time.Duration.Companion.minutes
import kotlin.time.toJavaDuration

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureWebTestClient
class CodeGenControllerIntegrationTest(
    @Autowired private val proxy: WireMockProxy
) : AbstractWiremockTest(proxy) {

    @Autowired
    lateinit var webTestClient: WebTestClient

    @Test
    fun `generateCode with input 7 should return OK`() {
        // setting higher timeout in case you need to generate the response again.
        // Deepseek API takes quite some time to respond.
        val customClient = webTestClient.mutate()
            .responseTimeout(5.minutes.toJavaDuration())
            .build()

        customClient.get()
            .uri("/generate/7")
            .exchange()
            .expectStatus().isOk
            .expectBody()
            .jsonPath("$.choices[0].message.content").exists()
    }
}
========================================================================

File: ./src/test/kotlin/org/bullit/dsictwi/wiremock/WireMockProxy.kt

package org.bullit.dsictwi.wiremock

import org.springframework.beans.factory.annotation.Value
import org.springframework.context.annotation.PropertySource
import org.springframework.stereotype.Component

@PropertySource("classpath:application.yml")
@Component
data class WireMockProxy(
    @Value("\${wiremock-config.url}") val url: String,
    @Value("\${wiremock-config.port}") val port: Int,
    @Value("\${wiremock-config.recording}") val recording: Boolean
)
========================================================================

File: ./src/test/resources/application.yml

prompt:
  system:
    base: "You are a senior Java developer specializing in converting PL/SQL to maintainable Java code."
    rules:
      - "Use only provided context APIs"
      - "Maintain exact functional equivalence"
      - "Follow Java best practices"
      - "Never invent new APIs or field names, all the field names and functions that you need are present in the context that was passed"
      - "Include proper error handling"
      - "Predicates must only handle a single responsibility, so they can be combined using the predicate api in the top level predicate"
      - "Use modern Java features where appropriate"
    context-header: "Available Context APIs:"

  user:
    instructions:
      - "Convert the following PL/SQL to Java while respecting these rules:"
      - "Match the patterns from these examples:"
      - "Only use APIs from the provided context:"
    example-format: "Example %d:\nPL/SQL:\n%s\n\nJava:\n%s"
    target-header: "Target PL/SQL to convert:"

wiremock-config:
  url: https://api.deepseek.com
  port: 9081
  recording: false

deepseek:
  api-key: my-key
  model: deepseek-chat
  temperature: 0.2
  base-url: http://localhost:${wiremock-config.port}
  chat-url: /chat/completions
========================================================================

